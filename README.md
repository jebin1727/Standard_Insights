# Natural Language Analytics using RAG over SQL Database

## Overview
This system provides a natural language interface to a business database. It uses a Retrieval-Augmented Generation (RAG) architecture to dynamically fetch relevant database schema information and generate safe, accurate SQL queries via LLM (Groq Llama 3).

## Architecture
The application follows a Model-View-Controller (MVC) architectural pattern with additional services and utilities layers:

### MVC Structure
- **Models** (`app/models/`):
  - `database/`: Handles database connections
  - `schema/`: Manages schema retrieval and storage
  - `query/`: Handles SQL query execution

- **Views** (`app/views/`):
  - Handles response formatting and presentation logic

- **Controllers** (`app/api/controllers/`):
  - `query_controller.py`: Orchestrates the query processing flow

- **Services** (`app/services/`):
  - `rag_service.py`: Schema retrieval and RAG logic
  - `sql_generation_service.py`: LLM-based SQL generation
  - `safety_service.py`: SQL validation and safety checks
  - `response_service.py`: Natural language response generation

- **Utilities** (`app/utils/`):
  - `logger.py`: Application logging
  - `time_utils.py`: Time range resolution
  - `validators.py`: Input validation

- **Configuration** (`app/config/`):
  - `settings.py`: Application configuration and settings

### Flow
1. **Dynamic Schema Fetching**: At startup and runtime, the system queries `INFORMATION_SCHEMA.COLUMNS` to pull the latest column names, types, and comments for allowed tables.
2. **Schema RAG (Retriever)**: When a user asks a question, a TF-IDF based retriever selects the top-k most relevant table schema snippets to inject into the LLM prompt. This minimizes token usage and prevents confusion.
3. **Deterministic Time Resolution**: A dedicated time-range module resolves relative terms like "last month" or "this week" into absolute dates using the `Asia/Kolkata` timezone, ensuring the LLM doesn't guess dates.
4. **SQL Guard (Safety Layer)**: All generated SQL passes through a strict validation layer:
   - **AST Parsing**: Uses `sqlglot` to verify it's a single `SELECT` statement.
   - **Keyword Blocking**: Explicitly blocks `INSERT`, `UPDATE`, `DELETE`, `DROP`, `ALTER`, etc.
   - **Table Whitelist**: Ensures only allowed tables are referenced.
   - **No Comments/Tricks**: Blocks SQL comments and risky functions like `SLEEP()`.
5. **Database Execution**: Validated SQL is executed on a read-only database. Numerical results come directly from the DB execution.
6. **Hallucination Prevention**: The final response is generated by providing the LLM with the *actual* DB result and strict instructions to use only that data.

## RAG Flow
The Retrieval-Augmented Generation (RAG) flow works as follows:

1. **Schema Retrieval**: At application startup, the system fetches all available table schemas from the database using `INFORMATION_SCHEMA.COLUMNS`
2. **Indexing**: Schema information is indexed using TF-IDF vectorization for efficient similarity matching
3. **Query Processing**: When a user query is received:
   - The query is vectorized using the same TF-IDF approach
   - Cosine similarity is calculated between the query vector and schema vectors
   - Top-k most similar schema snippets are retrieved
   - These snippets are injected into the LLM prompt to provide context
4. **Optimization**: The system uses TF-IDF and cosine similarity to efficiently match user queries with relevant database schemas, minimizing token usage and improving response accuracy

## Prompt Strategy
The system uses a two-stage prompting strategy:
1. **SQL Generation Prompt**: A highly structured system prompt that enforces MySQL syntax, uses provided schema context, and strictly forbids non-SELECT queries. It includes explicit table mappings and JOIN logic to handle complex queries without hallucination. It also includes "escape hatches" (`__NEED_CLARIFICATION__` and `__NOT_DB__`) for handled edge cases.
2. **Natural Response Prompt**: A summarization prompt that takes the raw user query, the SQL executed, and the numerical/tabular results to generate a human-friendly answer. It enforces currency formatting (₹) and accuracy.

## SQL Safety Approach
The system implements multiple layers of SQL safety:

1. **Pre-generation Safety**: The LLM prompt explicitly forbids non-SELECT queries
2. **Keyword Blocking**: Explicitly blocks `INSERT`, `UPDATE`, `DELETE`, `DROP`, `ALTER`, `CREATE`, `TRUNCATE`, `REPLACE`, `GRANT`, `REVOKE` using word boundary matching to avoid false positives
3. **Function Blocking**: Blocks risky functions like `SLEEP`, `BENCHMARK`, `LOAD_FILE`, `INTO OUTFILE`, `INTO DUMPFILE`
4. **Multiple Statement Prevention**: Blocks multiple SQL statements by checking for semicolons
5. **Comment Prevention**: Blocks SQL comments (`--`, `/* */`) which could be used for injection
6. **AST Validation**: Uses `sqlglot` to parse the SQL and verify it's a valid SELECT statement
7. **Table Whitelist**: Ensures only allowed tables are referenced in the query
8. **Read-Only Database**: The database user has only SELECT permissions as an additional safety layer

## Assumptions and Limitations
- **Read-Only Access**: It is assumed the database user has only `SELECT` permissions. The SQL Guard is a secondary defense.
- **Table Scope**: The system currently only considers a whitelist of tables defined in `config.py`.
- **Ambiguity**: Highly ambiguous questions will trigger a clarification request rather than a "best guess" to maintain accuracy.
- **Language**: The system is optimized for English queries.

## Table Mappings
The system maps business concepts to the following database tables:
- **Sales / Orders**: `data_so_summary`
- **Customers**: `data_company_info`
- **SKUs / Products**: `data_prod_variant`
- **Order Details**: `data_so_details`

## API Specification
### POST `/ask`
**Request:**
```json
{
  "query": "What is the total sales value of last month?"
}
```
**Success Response:**
```json
{
  "sql": "SELECT SUM(total_cost) FROM data_so_summary WHERE so_date BETWEEN '2025-11-01' AND '2025-11-30'",
  "result": 1388103.68,
  "natural_response": "The total sales value for last month (November 2025) is ₹13,88,103.68."
}
```

## Handling Edge Cases
- **Ambiguous Question**: Returns a request for clarification.
- **Non-DB Question**: Informs the user the question is unrelated to business data.
- **Blocked SQL**: If the LLM generates an unsafe query, the system returns a safety block message.

## How to Run
1. Install dependencies: `pip install -r requirements.txt`
2. Create/update `.env` with DB credentials and Groq API key (see `.env.example`). For the UAT database:
   ```
   DB_HOST=IP
   DB_USER=DB User
   DB_PASSWORD=DB Pswd
   DB_NAME=DB Name
   DB_PORT=3306
   GROQ_API_KEY=your_groq_api_key_here
   ```
3. Start the server:
   ```bash
   python -m app.main
   ```
4. Access docs at `http://localhost:8005/docs`.

## Database Schema Information
The application automatically fetches the database schema at startup, including:
- Column names and data types
- Nullability information
- Primary and foreign key constraints

This schema information is used by the RAG system to help the LLM generate accurate SQL queries with correct column names.

## Production Considerations
- **Logging**: The application includes comprehensive logging in the `logs/` directory
- **Error Handling**: Robust error handling throughout the application
- **Input Validation**: Input validation at multiple layers
- **Security**: Multiple layers of SQL safety as described above